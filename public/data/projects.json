[
{
  "id": "context-kit-agx",
  "title": "Context Kit",
  "subtitle": "Agent Experience (AGx) Design",
  "color": "#8B5CF6",
  "logoUrl": "context-kit.svg",
  "description": "Pioneering work in Agent Experience Design, treating AI agents as primary users with their own needs and interaction patterns. Demonstrates how UX principles apply to designing for AI collaboration through semantic YAML architectures, service-oriented design, and persistent context systems.",
  "bullets": [
    "AGx Design: UX principles applied to AI agents as primary users",
    "75% token reduction through semantic YAML optimization (1000→300 lines)",
    "User research conducted WITH AI agents through iterative feedback",
    "Service-oriented architecture with parallel agent orchestration",
    "Persistent context via MCP - zero re-exploration overhead"
  ],
  "slides": [
    {
      "type": "html",
      "component": "ProjectIntro",
      "props": {
        "title": "Context Kit",
        "subtitle": "Agent Experience (AGx) Design",
        "description": "AI agents were re-exploring my project structure every conversation, wasting 26+ seconds scanning files, reading docs, and mapping relationships that hadn't changed. I realized agents have fundamentally different information needs than humans—they can consume thousands of lines instantly but waste time navigating file systems. AGx Design treats AI agents as primary users with their own interaction patterns and needs.",
        "bullets": [
          "Problem: Agents re-explored project structure every conversation (26+ seconds wasted)",
          "Insight: AI agents process information differently—instant consumption, inefficient navigation",
          "Solution: AGx Design applies UX principles to AI agent experience",
          "Result: 75% token reduction, 90% time reduction through user research WITH agents"
        ],
        "image": "context-kit-dashboard.png",
        "imageAlt": "Context Kit dashboard showing service health and knowledge graph"
      },
      "alt": "Introduction to Context Kit and Agent Experience Design"
    },
    {
      "type": "html",
      "component": "InteractiveCards",
      "props": {
        "title": "What is AGx Design?",
        "subtitle": "Applying UX principles to AI agent experience",
        "cards": [
          {
            "icon": "Brain",
            "label": "AGx Concept",
            "title": "What is AGx?",
            "content": "AGx (Agent Experience) Design applies UX principles to AI agent experience. Just as UX designers conduct user research with humans to understand mental models, I conduct user research WITH AI agents to understand what context formats work best for them.",
            "image": null,
            "position": "left"
          },
          {
            "icon": "Search",
            "label": "Research Method",
            "title": "How do you research agents?",
            "content": "I ask agents directly: 'What context helps you understand this better?' 'What's missing?' 'What's redundant?' Through iterative conversations, agents told me YAML semantic anchors reduce repetition, hierarchical structure mirrors their processing, and progressive disclosure lets them scan efficiently.",
            "image": null,
            "position": "right"
          },
          {
            "icon": "Target",
            "label": "Core Principles",
            "title": "AGx Design Principles",
            "content": "1. Understand agent cognition - how do AI agents process information? 2. Design for token efficiency - eliminate repetitive exploration. 3. Enable progressive disclosure - agents scan overview, drill down as needed. 4. Maintain human accessibility - humans must read and maintain the system.",
            "image": null,
            "position": "left"
          }
        ]
      },
      "alt": "AGx Design philosophy and core principles"
    },
    {
      "type": "html",
      "component": "ConversationExamples",
      "props": {
        "title": "User Research with AI Agents",
        "subtitle": "Iterative design decisions through agent feedback",
        "conversations": [
          {
            "id": "format-exploration",
            "topic": "Format Exploration: XML vs Markdown vs YAML",
            "exchanges": [
              {
                "type": "human",
                "speaker": "Tucker",
                "message": "Goal: a way to create context for an ai agent to understand a repo. Which formats are available? Which makes the most sense for an ai agent? And why. How might we ensure the final solution works for people and agents."
              },
              {
                "type": "agent",
                "speaker": "Claude",
                "message": "XML emerges as the optimal choice. It provides semantic clarity with clear boundaries between concepts, flexible metadata, token efficiency for quick section identification, and mixed human/agent readability."
              },
              {
                "type": "human",
                "speaker": "Tucker",
                "message": "The xml seems like a good direction but there is a lot of extra characters that would lead to context bloat."
              },
              {
                "type": "agent",
                "speaker": "Claude",
                "message": "You're absolutely right. Let me reconsider with token efficiency as the primary constraint. Markdown with conventions is the sweet spot: Natural for LLMs (trained heavily on markdown), minimal overhead (just ## and code fences), and human-readable by default. It gives you 98.5%+ token efficiency."
              },
              {
                "type": "human",
                "speaker": "Tucker",
                "message": "This feels like it would require a specific design standard to keep consistent. Is there a format that already has specifications but offers the same benefits?"
              },
              {
                "type": "agent",
                "speaker": "Claude",
                "message": "Excellent point. CommonMark + YAML Front Matter. This combination is fully specified: CommonMark has a complete, unambiguous spec, YAML 1.2 is ISO standard. You don't need to invent a format—CommonMark IS the specification."
              },
              {
                "type": "decision",
                "speaker": "Design Decision",
                "message": "Use CommonMark + YAML front matter. Create convention document defining required sections (Overview, Structure, Files) + JSON Schema for front matter validation. Leverage existing specs rather than inventing new format."
              }
            ]
          },
          {
            "id": "token-optimization",
            "topic": "Box Characters: Token Optimization",
            "exchanges": [
              {
                "type": "human",
                "speaker": "Tucker",
                "message": "Does my addition of the 'never use box characters' create confusion or contradict other parts of the spec? The box characters contribute to context bloat."
              },
              {
                "type": "agent",
                "speaker": "Claude",
                "message": "Good catch! You're right—there's a contradiction. Section 4.1.3 says 'NEVER use box characters' but Section 6.1 says 'indentation or tree characters.'"
              },
              {
                "type": "agent",
                "speaker": "Claude",
                "message": "I recommend Option 1: Remove tree characters entirely. Your instinct about token bloat is correct. Box characters add visual appeal but consume extra tokens for no semantic value."
              },
              {
                "type": "human",
                "speaker": "Tucker",
                "message": "Proceed with option 1."
              },
              {
                "type": "agent",
                "speaker": "Claude",
                "message": "Updated Section 4.1.3: 'MUST NOT use box-drawing characters (├──, │, └──, etc.)' and Section 6.1: 'Use consistent indentation only, no box-drawing characters.'"
              },
              {
                "type": "human",
                "speaker": "Tucker",
                "message": "Are there other places in the spec we could update to reduce token bloat?"
              },
              {
                "type": "agent",
                "speaker": "Claude",
                "message": "Great question! Section numbering (~5% savings), repetitive MUST/SHOULD/MAY (~10% savings), duplicate examples, and verbose field descriptions. Could reduce the spec by 20-30% without losing essential information."
              },
              {
                "type": "decision",
                "speaker": "Design Decision",
                "message": "Removed box characters completely. Updated spec to 'indentation only, no box-drawing characters.' Extended principle to all context design: every character must justify its token cost. Tucker identified bloat issue and drove optimization."
              }
            ]
          }
        ]
      },
      "alt": "User research conversations with AI agents"
    },
     {
      "type": "html",
      "component": "YAMLContextViewer",
      "props": {},
      "alt": "Interactive YAML optimization demonstration"
    },
    {
      "type": "html",
      "component": "InteractiveCards",
      "props": {
        "title": "Service-Oriented Architecture",
        "subtitle": "Modular services optimized for different user types",
        "cards": [
          {
            "icon": "Layout",
            "label": "Visual Interface",
            "title": "React Dashboard (Port 42001)",
            "content": "Unified React dashboard aggregating all toolkit functionality. Provides real-time service health monitoring, log viewing, and performance metrics. Human-optimized interface with visual feedback and interactive controls.",
            "image": null,
            "position": "left"
          },
          {
            "icon": "Database",
            "label": "Data Backend",
            "title": "Knowledge Graph API (Port 42003)",
            "content": "SQLite + FTS5 storage enabling agents to query component relationships without file traversal. HTTP API provides structured access to entities, relationships, and project knowledge graph. Agent-optimized for fast context retrieval.",
            "image": null,
            "position": "right"
          },
          {
            "icon": "FileText",
            "label": "Debug Intelligence",
            "title": "Logging Service",
            "content": "Centralized logging service with structured output for debugging. Agents can reference logs to understand system behavior, trace execution paths, and identify issues without manual exploration. Multi-environment capture (browser, Node, terminal).",
            "image": null,
            "position": "left"
          },
          {
            "icon": "Zap",
            "label": "Persistent Memory",
            "title": "MCP Integration",
            "content": "Model Context Protocol server providing persistent AI memory across conversations. Context automatically loaded every conversation—no more re-exploration of project structure. Zero overhead context awareness via STDIO protocol.",
            "image": null,
            "position": "right"
          }
        ]
      },
      "alt": "Service-oriented architecture breakdown"
    },
    {
      "type": "html",
      "component": "BeforeAfter",
      "props": {
        "title": "Conversation Efficiency Transformation",
        "beforeTitle": "Without Context Kit",
        "beforeDescription": "Agent exploration overhead every conversation",
        "beforeImage": null,
        "beforePoints": [
          "Search for component files (8 seconds)",
          "Read existing documentation (12 seconds)",
          "Map project structure (6 seconds)",
          "Finally answer the question",
          "~3,200 tokens consumed in exploration"
        ],
        "beforePainPoints": [
          "Every conversation starts with re-learning",
          "Wasted time on repetitive exploration",
          "Token budget depleted on context setup",
          "No persistent memory between sessions"
        ],
        "afterTitle": "With Context Kit",
        "afterDescription": "Instant context awareness from conversation start",
        "afterImage": null,
        "afterPoints": [
          "Context pre-loaded via MCP",
          "Immediate project understanding",
          "Direct task execution",
          "~800 tokens for full context",
          "Zero re-exploration overhead"
        ],
        "afterBenefits": [
          "Instant conversation productivity",
          "75% token reduction (3200 → 800)",
          "90% time reduction (26s → 2-3s)",
          "Persistent context across sessions"
        ],
        "metrics": [
          {
            "label": "Time to First Response",
            "before": "26+ seconds",
            "after": "2-3 seconds",
            "improvement": "90% reduction"
          },
          {
            "label": "Token Consumption",
            "before": "~3,200 tokens",
            "after": "~800 tokens",
            "improvement": "75% reduction"
          },
          {
            "label": "Context Re-exploration",
            "before": "Every conversation",
            "after": "Never",
            "improvement": "100% elimination"
          },
          {
            "label": "Agent Efficiency",
            "before": "70% overhead",
            "after": "5% overhead",
            "improvement": "93% improvement"
          }
        ]
      },
      "alt": "Before and after context efficiency comparison"
    }
  ]
}
]